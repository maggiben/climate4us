{"ts":1357301863639,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"(function($) {\n    \"use strict\";\n\t\n\tvar getEventListeners = function( data, event ) {\n\t\tvar metadata = data.__observable;\n\t\tif (metadata.eventlisteners === undefined) {\n\t\t\tmetadata.eventlisteners = {\n\t\t\t\t'change': []\n\t\t\t};\n\t\t}\n\t\tif ( event === undefined ) {\n\t\t\treturn metadata.eventlisteners;\n\t\t}\n\t\tif ( metadata.eventlisteners[event] === undefined ) {\n\t\t\tmetadata.eventlisteners[event] = [];\n\t\t}\n\t\treturn metadata.eventlisteners[event];\n\t};\n\t\n\tvar fireEvent = function(data, event, params) {\n\t\tvar listeners = getEventListeners(data, event);\n\t\t// listeners.length can change during the iteration, since\n\t\t// the event handlers can add new event handlers for the fired event.\n\t\t// we don't want to run the event handlers which have been added after\n\t\t// the event occured (ie. which has been added after the iteration has been started)\n\t\t// therefore we save the current number of listeners to a local variable\n\t\t// before starting the iteration\n\t\tvar listenerCount = listeners.length;\n\t\tfor ( var i = 0; i < listenerCount; ++i ) {\n\t\t\tvar listener = listeners[i];\n\t\t\tif (listener === undefined)\n\t\t\t\tcontinue;\n\t\t\t// listener.isRunning is a flag/lock to avoid infinite recursions (eg. when the data is modified\n\t\t\t// by the listener function, then the same listener won't be called again\n\t\t\tif ( ! listener.isRunning ) {\n\t\t\t\tlistener.isRunning = true;\n\t\t\t\tlistener.fn.apply(data, params);\n\t\t\t\tlistener.isRunning = false;\n\t\t\t}\n\t\t}\n\t};\n\t\n\t\n\t// this function will be the on() method of all wrappers\n\tvar listenerAdder = function(event, listener) {\n\t\tif ( $.isArray( event ) ) {\n\t\t\tvar rval = [];\n\t\t\tfor ( var i = 0; i < event.length; ++i ) {\n\t\t\t\trval.push( this.on( event[ i ], listener ) );\n\t\t\t}\n\t\t\treturn rval;\n\t\t}\n\t\tvar listeners = getEventListeners(this, event);\n\t\tvar rval = listeners.length;\n\t\tlisteners.push({\n\t\t\tfn: listener\n\t\t});\n\t\treturn rval;\n\t};\n\t\n\tvar listenerRemover = function(event, listenerID) {\n\t\tvar listeners = getEventListeners(this, event);\n\t\tif (listeners[listenerID] !== undefined) {\n\t\t\tlisteners[listenerID] = undefined;\n\t\t}\n\t};\n\t\n\tvar listenerCount = function(event) {\n\t\tvar eventListeners = getEventListeners(this, event);\n\t\tvar rval = 0;\n\t\tfor (var i = 0; i < eventListeners.length; ++i) {\n\t\t\tif ( eventListeners[i] ){\n\t\t\t\t++rval;\n\t\t\t}\n\t\t}\n\t\treturn rval;\n\t}\n\t\t\n\tvar createObservableObject = function(value) {\n\t\tif ( $.isPlainObject(value) ) {\n\t\t\tfor ( var i in value ) {\n\t\t\t\tif (value.hasOwnProperty( i )) {\n\t\t\t\t\tvalue[ i ] = $.observable( value[ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar observable = function observableObject() {\n\t\t\tif (arguments.length === 0) { // getter\n\t\t\t\treturn value;\n\t\t\t} else { // setter\n\t\t\t\tvar oldVal = $.observable.remove(observable);\n\t\t\t\tvalue = arguments[ 0 ];\n\t\t\t\n                var isObservable = ($.isFunction( value )\n                      && value.__observable !== undefined );\n\t\t\t\n                if (isObservable) {\n                      value = value();\n                }\n\n\t\t\t\tif ( $.isPlainObject( value ) ) {\n\t\t\t\t\tfor (var i in value) {\n\t\t\t\t\t\tif (value.hasOwnProperty( i )) {\n\t\t\t\t\t\t\tvalue[ i ] = $.observable( value[ i ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfireEvent( observable, 'change', [observable, oldVal] );\n\t\t\t}\n\t\t};\n\t\t\n\t\tobservable.__observable = {};\n\t\t\n\t\tobservable.on = listenerAdder;\n\t\t\n\t\tobservable.off = listenerRemover;\n\t\t\n\t\tobservable.listenerCount = listenerCount;\n\t\t\n\t\treturn observable;\n\t};\n\t\n\tvar observableArrayItems = function(arr) {\n\t\tfor (var i = 0; i < arr.length; ++i) {\n\t\t\tarr[ i ] = $.observable(arr[ i ]);\n\t\t}\n\t\treturn arr;\n\t};\n\t\n\tvar createObservableArray = function(arr) {\n\t\t\n\t\tvar observable = function() {\n\t\t\tvar oldVal, newVal;\n\t\t\tswitch (arguments.length) {\n\t\t\t\tcase 0:\n\t\t\t\t\treturn arr;\n\t\t\t\tcase 1:\n\t\t\t\t\tvar arg = arguments[0];\n\t\t\t\t\tif ( $.isArray( arg ) ) {\n\t\t\t\t\t\toldVal = $.observable.remove(arr);\n\t\t\t\t\t\tarr = observableArrayItems( arg );\n\t\t\t\t\t\tfireEvent(observable, 'change', [arr, oldVal ]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn arr[ arg ];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\toldVal = $.observable.remove( arr[ arguments[0] ] );\n\t\t\t\t\tarr[ arguments[0] ] = newVal = $.observable( arguments[1] );\n\t\t\t\t\tfireEvent(observable, 'elemchange', [arguments[0], newVal, oldVal]);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow \"must be called with 1 or 2 arguments, not \" + arguments.length;\n\t\t\t}\n\t\t};\n\t\t\n\t\tarr = observableArrayItems( arr );\n\t\t\n\t\tobservable.__observable = {};\n\t\t\n\t\tobservable.on = listenerAdder;\n\t\t\n\t\tobservable.push = function(newItem) {\n\t\t\tnewItem = $.observable(newItem);\n\t\t\tarr.push( newItem );\n\t\t\tfireEvent( this, 'push', [newItem] );\n\t\t};\n\t\t\n\t\tobservable.forEach = function( callback ) {\n\t\t\tfor ( var i = 0; i < arr.length; ++i ) {\n\t\t\t\tif ( callback.call( null, i, arr[i] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\t\n\t\tobservable.size = function() {\n\t\t\treturn arr.length;\n\t\t};\n\t\t\n\t\tobservable.pop = function() {\n\t\t\tvar rval = arr.pop();\n\t\t\tfireEvent( this, 'pop', [rval] );\n\t\t\treturn rval;\n\t\t};\n\t\t\n\t\tobservable.reverse = function() {\n\t\t\tarr.reverse();\n\t\t\tfireEvent( this, 'reverse', [] );\n\t\t};\n\t\t\n\t\tobservable.shift = function() {\n\t\t\tvar rval = arr.shift();\n\t\t\tfireEvent( this, 'shift', [rval] );\n\t\t\treturn rval;\n\t\t};\n\t\tobservable.sort = function( callback ) {\n\t\t\tif ( callback ) {\n\t\t\t\tif ( ! $.isFunction( callback )) {\n\t\t\t\t\tthrow \"ArrayWrapper.sort() can only accept function parameter\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcallback = function(a, b) { // a default callback with lexicographical ordering.\n\t\t\t\t\ta = a.toString();\n\t\t\t\t\tb = b.toString();\n\t\t\t\t\tif (a === b) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t} else if (a < b) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t\treturn 1;\n\t\t\t\t};\n\t\t\t}\n\t\t\tvar comparator = function(a, b) {\n\t\t\t\treturn callback($.observable.remove( a ), \n\t\t\t\t\t$.observable.remove( b )); // unwrapping the items before passing them to the callback\n\t\t\t};\n\t\t\t\n\t\t\treturn arr.sort(comparator);\n\t\t};\n\t\tobservable.unshift = function(elem) {\n\t\t\telem = $.observable( elem );\n\t\t\tarr.unshift( elem );\n\t\t\tfireEvent(this, 'unshift', [elem] );\n\t\t};\n\t\t\n\t\t\n\t\treturn observable;\n\t};\n\t\t\n\t\n\t$.observable = function(data) {\n\t\tif ( $.isArray(data) ) {\n\t\t\treturn createObservableArray( data );\n\t\t}\n\t\tif ( $.isFunction(data) && data.__observable ) {\n\t\t\treturn data;\n\t\t}\n\t\treturn createObservableObject( data );\n\t};\n\t\n\t$.observable.remove = function(data) {\n\t\tvar rval = [], i;\n\t\tif ( ! $.isFunction(data)) {\n\t\t\tif ( $.isArray(data) ) {\n\t\t\t\tfor ( i = 0; i < data.length; ++i ) {\n\t\t\t\t\trval[ i ] = $.observable.remove( data[ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn rval;\n\t\t}\n\t\tvar rawData = data(); // getting the raw object\n\t\t\n\t\tif ( $.isArray(rawData) ) {\n\t\t\tfor( i = 0; i < rawData.length; ++i ) {\n\t\t\t\trval[ i ] = $.observable.remove( rawData[ i ] );\n\t\t\t}\n\t\t\treturn rval;\n\t\t} else if ($.isPlainObject( rawData ) ) {\n\t\t\trval = {};\n\t\t\tfor ( var prop in rawData ) {\n\t\t\t\tif (rawData.hasOwnProperty(prop)) {\n\t\t\t\t\trval[ prop ] = $.observable.remove( rawData[ prop ] );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn rval;\n\t\t}\n\t\treturn rawData;\n\t};\n\t\n})(jQuery);\n"]],"start1":0,"start2":0,"length1":0,"length2":6854}]],"length":6854}
