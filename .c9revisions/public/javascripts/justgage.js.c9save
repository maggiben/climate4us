{"ts":1356751952777,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/**\n * JustGage - this is work-in-progress, unreleased, unofficial code, so it might not work top-notch :) \n * Check http://www.justgage.com for official releases\n * Licensed under MIT.\n * @author Bojan Djuricic  (@Toorshia)\n * \n * LATEST UPDATES\n * -----------------------------\n * November 25, 2012.\n * -----------------------------\n * Option to define custom rendering function for displayed value\n * ----------------------------- \n * November 19, 2012.\n * -----------------------------\n * Config.value is now updated after gauge refresh\n * -----------------------------\n * November 13, 2012.\n * -----------------------------\n * Donut display mode added\n * Option to hide value label\n * Option to enable responsive gauge size\n * Removed default title attribute\n * Option to accept min and max defined as string values\n * Option to configure value symbol\n * Fixed bad aspect ratio calculations\n * Option to configure minimum font size for all texts\n * Option to show shorthand big numbers (human friendly)\n */\n\nJustGage = function(config) { \n  \n  if (!config.id) {alert(\"Missing id parameter for gauge!\"); return false;} \n  if (!document.getElementById(config.id)) {alert(\"No element with id: \\\"\"+config.id+\"\\\" found!\"); return false;} \n  \n  // configurable parameters\n  this.config = \n  {\n    // id : string \n    // this is container element id\n    id : config.id,\n    \n    // title : string\n    // gauge title \n    title : (config.title) ? config.title : \"\",\n    \n    // titleFontColor : string\n    // color of gauge title \n    titleFontColor : (config.titleFontColor) ? config.titleFontColor : \"#999999\",\n    \n    // value : int\n    // value gauge is showing \n    value : (config.value) ? config.value : 0,\n    \n    // symbol : string\n    // special symbol to show next to value \n    symbol : (config.symbol) ? config.symbol : \"\",\n    \n    // valueFontColor : string\n    // color of label showing current value\n    valueFontColor : (config.valueFontColor) ? config.valueFontColor : \"#010101\",\n    \n    // showValue : bool\n    // hide or display value text\n    showValue : (config.showValue != null) ? config.showValue : true,\n    \n    // min : int\n    // min value\n    min : (config.min) ? parseFloat(config.min) : 0,\n    \n    // max : int\n    // max value\n    max : (config.max) ? parseFloat(config.max) : 100,\n    \n    // showMinMax : bool\n    // hide or display min and max values\n    showMinMax : (config.showMinMax != null) ? config.showMinMax : true,\n    \n    // humanFriendly : bool\n    // convert large numbers for min, max, value to human friendly (e.g. 1234567 -> 1.23M)\n    humanFriendly : (config.humanFriendly) ? config.humanFriendly : false,\n    \n    // humanFriendlyDecimal : int\n    // number of decimal places for our human friendly number to contain\n    humanFriendlyDecimal : (config.humanFriendlyDecimal) ? config.humanFriendlyDecimal : 0,\n    \n    // textRenderer: func\n    // function applied before rendering text\n    textRenderer  : (config.textRenderer) ? config.textRenderer : null,\n\n    // gaugeWidthScale : float\n    // width of the gauge element\n    gaugeWidthScale : (config.gaugeWidthScale) ? config.gaugeWidthScale : 1.0,\n    \n    // gaugeColor : string\n    // background color of gauge element \n    gaugeColor : (config.gaugeColor) ? config.gaugeColor : \"#edebeb\",\n    \n    // label : string\n    // text to show below value\n    label : (config.label) ? config.label : \"\",\n    \n    // showInnerShadow : bool\n    // give gauge element small amount of inner shadow \n    showInnerShadow : (config.showInnerShadow != null) ? config.showInnerShadow : true,\n    \n    // shadowOpacity : int\n    // 0 ~ 1\n    shadowOpacity : (config.shadowOpacity) ? config.shadowOpacity : 0.2,\n    \n    // shadowSize: int\n    // inner shadow size\n    shadowSize : (config.shadowSize) ? config.shadowSize : 5,\n    \n    // shadowVerticalOffset : int\n    // how much shadow is offset from top \n    shadowVerticalOffset : (config.shadowVerticalOffset) ? config.shadowVerticalOffset : 3,\n    \n    // levelColors : string[]\n    // colors of indicator, from lower to upper, in RGB format \n    levelColors : (config.levelColors) ? config.levelColors : [\n      \"#a9d70b\",\n      \"#f9c802\",\n      \"#ff0000\"\n    ],\n    \n    // levelColorsGradient : bool\n    // whether to use gradual color change for value, or sector-based\n    levelColorsGradient : (config.levelColorsGradient != null) ? config.levelColorsGradient : true,\n    \n    // labelFontColor : string\n    // color of label showing label under value\n    labelFontColor : (config.labelFontColor) ? config.labelFontColor : \"#b3b3b3\",\n    \n    // startAnimationTime : int\n    // length of initial animation \n    startAnimationTime : (config.startAnimationTime) ? config.startAnimationTime : 700,\n    \n    // startAnimationType : string\n    // type of initial animation (linear, >, <,  <>, bounce) \n    startAnimationType : (config.startAnimationType) ? config.startAnimationType : \">\",\n    \n    // refreshAnimationTime : int\n    // length of refresh animation \n    refreshAnimationTime : (config.refreshAnimationTime) ? config.refreshAnimationTime : 700,\n    \n    // refreshAnimationType : string\n    // type of refresh animation (linear, >, <,  <>, bounce) \n    refreshAnimationType : (config.refreshAnimationType) ? config.refreshAnimationType : \">\",\n\n    // donut : bool\n    // show full donut gauge \n    donut : (config.donut != null) ? config.donut : false,\n    \n    // valueMinFontSize : int\n    // absolute minimum font size for the value\n    valueMinFontSize : config.valueMinFontSize || 16,\n\t\n    // titleMinFontSize\n    // absolute minimum font size for the title\n    titleMinFontSize : config.titleMinFontSize || 10,\n\t\n    // labelMinFontSize\n    // absolute minimum font size for the label\n    labelMinFontSize : config.labelMinFontSize || 10,\n\t\n    // minLabelMinFontSize\n    // absolute minimum font size for the minimum label\n    minLabelMinFontSize : config.minLabelMinFontSize || 10,\n\t\n    // maxLabelMinFontSize\n    // absolute minimum font size for the maximum label\n    maxLabelMinFontSize : config.maxLabelMinFontSize || 10,\n    \n    // relativeGaugeSize : bool\n    // whether gauge size should follow changes in container element size\n    relativeGaugeSize : (config.relativeGaugeSize != null) ? config.relativeGaugeSize : false\n  };\n  \n  // overflow values\n  if (config.value > this.config.max) this.config.value = this.config.max; \n  if (config.value < this.config.min) this.config.value = this.config.min;\n  this.originalValue = config.value;\n  \n  // canvas\n  this.canvas = Raphael(this.config.id, \"100%\", \"100%\");\n  if (this.config.relativeGaugeSize) {\n    this.canvas.setViewBox(0, 0, 200, 150, true);\n  }\n  \n  // canvas dimensions\n  var canvasW, canvasH;\n  if (this.config.relativeGaugeSize) {\n    canvasW = 200;\n    canvasH = 150;\n  } else {\n    canvasW = getStyle(document.getElementById(this.config.id), \"width\").slice(0, -2) * 1;\n    canvasH = getStyle(document.getElementById(this.config.id), \"height\").slice(0, -2) * 1;\n  }\n  \n  // widget dimensions\n  var widgetW, widgetH, aspect;\n  \n  if (this.config.donut) {\n    \n    // DONUT ******************************* \n\n    // width more than height\n    if(canvasW > canvasH) {\n      widgetH = canvasH;\n      widgetW = widgetH;\n    // width less than height\n    } else if (canvasW < canvasH) {\n      widgetW = canvasW;\n      widgetH = widgetW;\n      // if height don't fit, rescale both\n      if(widgetH > canvasH) {\n        aspect = widgetH / canvasH;\n        widgetH = widgetH / aspect;\n        widgetW = widgetH / aspect;\n      }\n    // equal\n    } else {\n      widgetW = canvasW;\n      widgetH = widgetW;\n    }\n    \n    // delta \n    var dx = (canvasW - widgetW)/2;\n    var dy = (canvasH - widgetH)/2;\n    \n    // title \n    var titleFontSize = ((widgetH / 8) > 10) ? (widgetH / 10) : 10;\n    var titleX = dx + widgetW / 2;\n    var titleY = dy + widgetH / 15;\n    \n    // value \n    var valueFontSize = ((widgetH / 6.4) > 16) ? (widgetH / 5.4) : 18;\n    var valueX = dx + widgetW / 2;\n    var valueY = dy + widgetH / 1.95;\n    \n    // label \n    var labelFontSize = ((widgetH / 16) > 10) ? (widgetH / 16) : 10;\n    var labelX = dx + widgetW / 2;\n    var labelY = valueY + valueFontSize / 2 + 6;\n    \n    // min \n    var minFontSize = ((widgetH / 16) > 10) ? (widgetH / 16) : 10;\n    var minX = dx + (widgetW / 10) + (widgetW / 6.666666666666667 * this.config.gaugeWidthScale) / 2 ;\n    var minY = dy + widgetH / 2;\n    \n    // max \n    var maxFontSize = ((widgetH / 16) > 10) ? (widgetH / 16) : 10;\n    var maxX = dx + widgetW - (widgetW / 10) - (widgetW / 6.666666666666667 * this.config.gaugeWidthScale) / 2 ;\n    var maxY = dy + widgetH / 2;\n    \n  } else {\n    // HALF ******************************* \n    \n    // width more than height\n    if(canvasW > canvasH) {\n      widgetH = canvasH;\n      widgetW = widgetH * 1.25;\n      //if width doesn't fit, rescale both\n      if(widgetW > canvasW) {\n          aspect = widgetW / canvasW;\n          widgetW = widgetW / aspect;\n          widgetH = widgetH / aspect;\n      }\n    // width less than height\n    } else if (canvasW < canvasH) {\n      widgetW = canvasW;\n      widgetH = widgetW / 1.25;\n      // if height don't fit, rescale both\n      if(widgetH > canvasH) {\n        aspect = widgetH / canvasH;\n        widgetH = widgetH / aspect;\n        widgetW = widgetH / aspect;\n      }\n    // equal\n    } else {\n      widgetW = canvasW;\n      widgetH = widgetW * 0.75;\n    }\n  \n    // delta \n    var dx = (canvasW - widgetW)/2;\n    var dy = (canvasH - widgetH)/2;\n    \n    // title \n    var titleFontSize = ((widgetH / 8) > this.config.titleMinFontSize) ? (widgetH / 10) : this.config.titleMinFontSize;\n    var titleX = dx + widgetW / 2;\n    var titleY = dy + widgetH / 6.5;\n    \n    // value \n    var valueFontSize = ((widgetH / 6.4) > this.config.valueMinFontSize) ? (widgetH / 6.4) : this.config.valueMinFontSize;\n    var valueX = dx + widgetW / 2;\n    var valueY = dy + widgetH / 1.4;\n    \n    // label \n    var labelFontSize = ((widgetH / 16) > this.config.labelMinFontSize) ? (widgetH / 16) : this.config.labelMinFontSize;\n    var labelX = dx + widgetW / 2;\n    //var labelY = dy + widgetH / 1.126760563380282;\n    var labelY = valueY + valueFontSize / 2 + 6;\n    \n    // min \n    var minFontSize = ((widgetH / 16) > this.config.minLabelMinFontSize) ? (widgetH / 16) : this.config.minLabelMinFontSize;\n    var minX = dx + (widgetW / 10) + (widgetW / 6.666666666666667 * this.config.gaugeWidthScale) / 2 ;\n    var minY = dy + widgetH / 1.126760563380282;\n    \n    // max \n    var maxFontSize = ((widgetH / 16) > this.config.maxLabelMinFontSize) ? (widgetH / 16) : this.config.maxLabelMinFontSize;\n    var maxX = dx + widgetW - (widgetW / 10) - (widgetW / 6.666666666666667 * this.config.gaugeWidthScale) / 2 ;\n    var maxY = dy + widgetH / 1.126760563380282;\n  }\n  // parameters\n  this.params  = {\n    canvasW : canvasW,\n    canvasH : canvasH,\n    widgetW : widgetW,\n    widgetH : widgetH,\n    dx : dx,\n    dy : dy,\n    titleFontSize : titleFontSize,\n    titleX : titleX,\n    titleY : titleY,\n    valueFontSize : valueFontSize,\n    valueX : valueX,\n    valueY : valueY,\n    labelFontSize : labelFontSize,\n    labelX : labelX,\n    labelY : labelY,\n    minFontSize : minFontSize,\n    minX : minX,\n    minY : minY,\n    maxFontSize : maxFontSize,\n    maxX : maxX,\n    maxY : maxY\n  };\n  \n  // pki - custom attribute for generating gauge paths\n  this.canvas.customAttributes.pki = function (value, min, max, w, h, dx, dy, gws, donut) {\n    \n       if (donut) {\n         var \n            alpha = (1 - 2 * (value - min) / (max - min)) * Math.PI,\n            Ro = w / 2 - w / 7,\n            Ri = Ro - w / 6.666666666666667 * gws,\n            \n            Cx = w / 2 + dx,\n            Cy = h / 1.95 + dy,\n            \n            Xo = w / 2 + dx + Ro * Math.cos(alpha),\n            Yo = h - (h - Cy) + 0 - Ro * Math.sin(alpha),\n            Xi = w / 2 + dx + Ri * Math.cos(alpha),\n            Yi = h - (h - Cy) + 0 - Ri * Math.sin(alpha),\n            path = \"\";\n      \n          path += \"M\" + (Cx - Ri) + \",\" + Cy + \" \";\n          path += \"L\" + (Cx - Ro) + \",\" + Cy + \" \";\n          if (value > ((max - min) / 2)) {\n            path += \"A\" + Ro + \",\" + Ro + \" 0 0 1 \" + (Cx + Ro) + \",\" + Cy + \" \";\n          }\n          path += \"A\" + Ro + \",\" + Ro + \" 0 0 1 \" + Xo + \",\" + Yo + \" \";\n          path += \"L\" + Xi + \",\" + Yi + \" \";\n          if (value > ((max - min) / 2)) {\n            path += \"A\" + Ri + \",\" + Ri + \" 0 0 0 \" + (Cx + Ri) + \",\" + Cy + \" \";\n          }\n          path += \"A\" + Ri + \",\" + Ri + \" 0 0 0 \" + (Cx - Ri) + \",\" + Cy + \" \";\n          path += \"Z \";\n          return { path: path };\n        \n      } else {\n        var \n            alpha = (1 - (value - min) / (max - min)) * Math.PI,\n\n            Ro = w / 2 - w / 10,\n            Ri = Ro - w / 6.666666666666667 * gws,\n            \n            Cx = w / 2 + dx,\n            Cy = h / 1.25 + dy,\n            \n            Xo = w / 2 + dx + Ro * Math.cos(alpha),\n            Yo = h - (h - Cy) + 0 - Ro * Math.sin(alpha),\n            Xi = w / 2 + dx + Ri * Math.cos(alpha),\n            Yi = h - (h - Cy) + 0 - Ri * Math.sin(alpha),\n            path = \"\";\n      \n        path += \"M\" + (Cx - Ri) + \",\" + Cy + \" \";\n        path += \"L\" + (Cx - Ro) + \",\" + Cy + \" \";\n        path += \"A\" + Ro + \",\" + Ro + \" 0 0 1 \" + Xo + \",\" + Yo + \" \";\n        path += \"L\" + Xi + \",\" + Yi + \" \";\n        path += \"A\" + Ri + \",\" + Ri + \" 0 0 0 \" + (Cx - Ri) + \",\" + Cy + \" \";\n        path += \"Z \";\n        return { path: path };\n      }\n  }  \n  \n  // gauge\n  this.gauge = this.canvas.path().attr({\n    \"stroke\": \"none\",\n    \"fill\": this.config.gaugeColor,   \n    pki: [this.config.max, this.config.min, this.config.max, this.params.widgetW, this.params.widgetH,  this.params.dx, this.params.dy, this.config.gaugeWidthScale, this.config.donut]\n  });\n  this.gauge.id = this.config.id+\"-gauge\";\n  \n  // level\n  this.level = this.canvas.path().attr({\n    \"stroke\": \"none\",\n    \"fill\": getColorForPercentage((this.config.value - this.config.min) / (this.config.max - this.config.min), this.config.levelColors, this.config.levelColorsGradient),  \n    pki: [this.config.min, this.config.min, this.config.max, this.params.widgetW, this.params.widgetH,  this.params.dx, this.params.dy, this.config.gaugeWidthScale, this.config.donut]\n  });\n  this.level.id = this.config.id+\"-level\";\n  \n  // title\n  this.txtTitle = this.canvas.text(this.params.titleX, this.params.titleY, this.config.title);\n  this.txtTitle. attr({\n    \"font-size\":this.params.titleFontSize,\n    \"font-weight\":\"bold\",\n    \"font-family\":\"Arial\",\n    \"fill\":this.config.titleFontColor,\n    \"fill-opacity\":\"1\"         \n  });\n  this.txtTitle.id = this.config.id+\"-txttitle\";\n  \n  // value\n  if(this.config.textRenderer)\n    this.originalValue = this.config.textRenderer(this.originalValue);\n  else if( this.config.humanFriendly ) \n    this.originalValue = humanFriendlyNumber( this.originalValue, this.config.humanFriendlyDecimal ) + this.config.symbol;\n\n  this.txtValue = this.canvas.text(this.params.valueX, this.params.valueY, this.originalValue);\n  this.txtValue. attr({\n    \"font-size\":this.params.valueFontSize,\n    \"font-weight\":\"bold\",\n    \"font-family\":\"Arial\",\n    \"fill\":this.config.valueFontColor,\n    \"fill-opacity\":\"0\"          \n  });\n  this.txtValue.id = this.config.id+\"-txtvalue\";\n  \n  // label\n  this.txtLabel = this.canvas.text(this.params.labelX, this.params.labelY, this.config.label);\n  this.txtLabel. attr({\n    \"font-size\":this.params.labelFontSize,\n    \"font-weight\":\"normal\",\n    \"font-family\":\"Arial\",\n    \"fill\":this.config.labelFontColor,   \n    \"fill-opacity\":\"0\"\n  });\n  this.txtLabel.id = this.config.id+\"-txtlabel\";\n  \n  // min\n  this.txtMinimum = this.config.min;\n  if( this.config.humanFriendly ) this.txtMinimum = humanFriendlyNumber( this.config.min, this.config.humanFriendlyDecimal );\n  this.txtMin = this.canvas.text(this.params.minX, this.params.minY, this.txtMinimum);\n  this.txtMin. attr({\n    \"font-size\":this.params.minFontSize,\n    \"font-weight\":\"normal\",\n    \"font-family\":\"Arial\",\n    \"fill\":this.config.labelFontColor,   \n    \"fill-opacity\": (this.config.showMinMax == true)? \"1\" : \"0\"\n  });\n  this.txtMin.id = this.config.id+\"-txtmin\";\n  \n  // max\n  this.txtMaximum = this.config.max;\n  if( this.config.humanFriendly ) this.txtMaximum = humanFriendlyNumber( this.config.max, this.config.humanFriendlyDecimal );\n  this.txtMax = this.canvas.text(this.params.maxX, this.params.maxY, this.txtMaximum);\n  this.txtMax. attr({\n    \"font-size\":this.params.maxFontSize,\n    \"font-weight\":\"normal\",\n    \"font-family\":\"Arial\",\n    \"fill\":this.config.labelFontColor,   \n    \"fill-opacity\": (this.config.showMinMax == true)? \"1\" : \"0\"\n  });\n  this.txtMax.id = this.config.id+\"-txtmax\";\n  \n  var defs = this.canvas.canvas.childNodes[1];\n  var svg = \"http://www.w3.org/2000/svg\";\n  \n  if (ie < 9) {\n    onCreateElementNsReady(function() {\n      this.generateShadow();\n    });  \n  } else {\n    this.generateShadow(svg, defs);\n    defs = null;\n    svg = null;\n  }\n  \n  // animate \n  this.level.animate({pki: [this.config.value, this.config.min, this.config.max, this.params.widgetW, this.params.widgetH,  this.params.dx, this.params.dy, this.config.gaugeWidthScale, this.config.donut]},  this.config.startAnimationTime, this.config.startAnimationType);\n  \n  if (this.config.showValue) {\n    this.txtValue.animate({\"fill-opacity\":\"1\"}, this.config.startAnimationTime, this.config.startAnimationType); \n  }\n  this.txtLabel.animate({\"fill-opacity\":\"1\"}, this.config.startAnimationTime, this.config.startAnimationType);  \n};\n\n/** Refresh gauge level */\nJustGage.prototype.refresh = function(val) {\n  // overflow values\n  var originalVal = val;\n  var displayVal = val;\n  if (val > this.config.max) {val = this.config.max;}\n  if (val < this.config.min) {val = this.config.min;}\n    \n  var color = getColorForPercentage((val - this.config.min) / (this.config.max - this.config.min), this.config.levelColors, this.config.levelColorsGradient);\n  \n  if(this.config.textRenderer)\n    displayVal = this.config.textRenderer(displayVal);\n  else if( this.config.humanFriendly ) \n    displayVal = humanFriendlyNumber( displayVal, this.config.humanFriendlyDecimal ) + this.config.symbol;\n\n  this.canvas.getById(this.config.id+\"-txtvalue\").attr({\"text\":displayVal});\n  this.canvas.getById(this.config.id+\"-level\").animate({pki: [val, this.config.min, this.config.max, this.params.widgetW, this.params.widgetH,  this.params.dx, this.params.dy, this.config.gaugeWidthScale, this.config.donut], \"fill\":color},  this.config.refreshAnimationTime, this.config.refreshAnimationType);\n  this.config.value = val;\n  originalVal = null;\n  displayVal = null;\n};\n\n/** Generate shadow */\nJustGage.prototype.generateShadow = function(svg, defs) {\n    // FILTER\n    var gaussFilter=document.createElementNS(svg,\"filter\");\n    gaussFilter.setAttribute(\"id\", this.config.id + \"-inner-shadow\");\n    defs.appendChild(gaussFilter);\n    \n    // offset\n    var feOffset = document.createElementNS(svg,\"feOffset\");\n    feOffset.setAttribute(\"dx\", 0);\n    feOffset.setAttribute(\"dy\", this.config.shadowVerticalOffset);\n    gaussFilter.appendChild(feOffset);\n    feOffset = null;\n    \n    // blur\n    var feGaussianBlur = document.createElementNS(svg,\"feGaussianBlur\");\n    feGaussianBlur.setAttribute(\"result\",\"offset-blur\");\n    feGaussianBlur.setAttribute(\"stdDeviation\", this.config.shadowSize);\n    gaussFilter.appendChild(feGaussianBlur);\n    feGaussianBlur = null;\n    \n    // composite 1\n    var feComposite1 = document.createElementNS(svg,\"feComposite\");\n    feComposite1.setAttribute(\"operator\",\"out\");\n    feComposite1.setAttribute(\"in\", \"SourceGraphic\");\n    feComposite1.setAttribute(\"in2\",\"offset-blur\");\n    feComposite1.setAttribute(\"result\",\"inverse\");\n    gaussFilter.appendChild(feComposite1);\n    feComposite1 = null;\n    \n    // flood\n    var feFlood = document.createElementNS(svg,\"feFlood\");\n    feFlood.setAttribute(\"flood-color\",\"black\");\n    feFlood.setAttribute(\"flood-opacity\", this.config.shadowOpacity);\n    feFlood.setAttribute(\"result\",\"color\");\n    gaussFilter.appendChild(feFlood);\n    feFlood = null;\n    \n    // composite 2\n    var feComposite2 = document.createElementNS(svg,\"feComposite\");\n    feComposite2.setAttribute(\"operator\",\"in\");\n    feComposite2.setAttribute(\"in\", \"color\");\n    feComposite2.setAttribute(\"in2\",\"inverse\");\n    feComposite2.setAttribute(\"result\",\"shadow\");\n    gaussFilter.appendChild(feComposite2);\n    feComposite2 = null;\n    \n    // composite 3\n    var feComposite3 = document.createElementNS(svg,\"feComposite\");\n    feComposite3.setAttribute(\"operator\",\"over\");\n    feComposite3.setAttribute(\"in\", \"shadow\");\n    feComposite3.setAttribute(\"in2\",\"SourceGraphic\");\n    gaussFilter.appendChild(feComposite3);\n    feComposite3 = null;\n\n    // set shadow\n    if (this.config.showInnerShadow == true) {\n      this.canvas.canvas.childNodes[2].setAttribute(\"filter\", \"url(#\" + this.config.id + \"-inner-shadow)\");\n      this.canvas.canvas.childNodes[3].setAttribute(\"filter\", \"url(#\" + this.config.id + \"-inner-shadow)\");\n    }\n    \n    // clear vars\n    gaussFilter = null;\n    \n}\n\n/** Get color for value percentage */\nfunction getColorForPercentage(pct, col, grad) {\n    \n    var no = col.length;\n    if (no === 1) return col[0];\n    var inc = (grad) ? (1 / (no - 1)) : (1 / no);\n    var colors = new Array();\n    for (var i = 0; i < col.length; i++) {\n      var percentage = (grad) ? (inc * i) : (inc * (i + 1));\n      var rval = parseInt((cutHex(col[i])).substring(0,2),16);\n      var gval = parseInt((cutHex(col[i])).substring(2,4),16);\n      var bval = parseInt((cutHex(col[i])).substring(4,6),16);\n      colors[i] = { pct: percentage, color: { r: rval, g: gval, b: bval  } };\n    }\n        \n    if(pct == 0) return 'rgb(' + [colors[0].color.r, colors[0].color.g, colors[0].color.b].join(',') + ')';\n    \n    for (var i = 0; i < colors.length; i++) {\n        if (pct <= colors[i].pct) {\n          if (grad == true) {\n            var lower = colors[i - 1];\n            var upper = colors[i];\n            var range = upper.pct - lower.pct;\n            var rangePct = (pct - lower.pct) / range;\n            var pctLower = 1 - rangePct;\n            var pctUpper = rangePct;\n            var color = {\n                r: Math.floor(lower.color.r * pctLower + upper.color.r * pctUpper),\n                g: Math.floor(lower.color.g * pctLower + upper.color.g * pctUpper),\n                b: Math.floor(lower.color.b * pctLower + upper.color.b * pctUpper)\n            };\n            return 'rgb(' + [color.r, color.g, color.b].join(',') + ')';\n          } else {\n            return 'rgb(' + [colors[i].color.r, colors[i].color.g, colors[i].color.b].join(',') + ')'; \n          }\n        }\n    }\n\n} \n\n/** Random integer  */\nfunction getRandomInt (min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n}    \n\n/**  Cut hex  */\nfunction cutHex(str) {return (str.charAt(0)==\"#\") ? str.substring(1,7):str}\n\n/**  Human friendly number suffix */\n// From: http://stackoverflow.com/questions/2692323/code-golf-friendly-number-abbreviator\nfunction humanFriendlyNumber( n, d ) {\n\tvar p = Math.pow;\n\tvar d = p(10,d);\n\tvar i = 7\n\twhile( i ) {\n\t\ts = p(10,i--*3)\n\t\tif( s <= n ) {\n\t\t\tn = Math.round(n*d/s)/d+\"kMGTPE\"[i];\n\t\t}\n\t}\n\treturn n;\n}\n\n/**  Get style  */\nfunction getStyle(oElm, strCssRule){\n\tvar strValue = \"\";\n\tif(document.defaultView && document.defaultView.getComputedStyle){\n\t\tstrValue = document.defaultView.getComputedStyle(oElm, \"\").getPropertyValue(strCssRule);\n\t}\n\telse if(oElm.currentStyle){\n\t\tstrCssRule = strCssRule.replace(/\\-(\\w)/g, function (strMatch, p1){\n\t\t\treturn p1.toUpperCase();\n\t\t});\n\t\tstrValue = oElm.currentStyle[strCssRule];\n\t}\n\treturn strValue;\n}\n\n/**  Create Element NS Ready  */\n function onCreateElementNsReady(func) {\n  if (document.createElementNS != undefined) {\n    func();\n  } else {\n    setTimeout(function() { onCreateElementNsReady(func); }, 100);\n  }\n}\n\n/**  Get IE version  */\n// ----------------------------------------------------------\n// A short snippet for detecting versions of IE in JavaScript\n// without resorting to user-agent sniffing\n// ----------------------------------------------------------\n// If you're not in IE (or IE version is less than 5) then:\n// ie === undefined\n// If you're in IE (>=5) then you can determine which version:\n// ie === 7; // IE7\n// Thus, to detect IE:\n// if (ie) {}\n// And to detect the version:\n// ie === 6 // IE6\n// ie > 7 // IE8, IE9 ...\n// ie < 9 // Anything less than IE9\n// ----------------------------------------------------------\n// UPDATE: Now using Live NodeList idea from @jdalton\nvar ie = (function(){\n\n    var undef,\n        v = 3,\n        div = document.createElement('div'),\n        all = div.getElementsByTagName('i');\n\n    while (\n        div.innerHTML = '<!--[if gt IE ' + (++v) + ']><i></i><![endif]-->',\n        all[0]\n    );\n\n    return v > 4 ? v : undef;\n\n}());\n"]],"start1":0,"start2":0,"length1":0,"length2":24997}]],"length":24997}
